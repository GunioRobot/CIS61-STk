okay
STk> (define (fract-stream x)
  (if (null? x) (error "Null list")
      (let ((numer (car x))
	    (denom (cadr x)))
	(cond ((> numer denom) (error "Numerator greater than denominator"))
	      ((or (< numer 0) (< denom 0)) (error "Must use positive integers"))
	      ((divisible? numer denom) (cons-stream (/ numer denom) the-empty-stream))
	      (else (cons-stream (truncate (/ (* numer 10) denom))
				 (fract-stream (list (remainder (* numer 10) denom) denom))))))))
fract-stream
STk> (define (approximation fs numdigits)
  (if (= numdigits 0) nil
      (if (stream-null? fs) (begin
			      (append (list 0)
				      (approximation fs (- numdigits 1))))
	  (append (list (stream-car fs))
		  (approximation (stream-cdr fs) (- numdigits 1))))))
approximation
STk> (define (divisible? n1 n2)
  (= (remainder n1 n2) 0))
divisible?
STk> (fract-stream '(1 7))
(1 . #[promise 448c60 (not forced)])
STk> (fract-stream '(2 4))
(5 . #[promise 44a4f0 (not forced)])
STk> (approximation (fract-stream '(1 7)) 4)
(1 4 2 8)
STk> (approximation (fract-stream '(1 7)) 5)
(1 4 2 8 5)
STk> (approximation (fract-stream '(1 7)) 10)
(1 4 2 8 5 7 1 4 2 8)
STk> (approximation (fract-stream '(2 4)) 1)
(5)
STk> (approximation (fract-stream '(2 4)) 2)
(5 0)
STk> (approximation (fract-stream '(2 4)) 5)
(5 0 0 0 0)
STk> (transcript-off)
